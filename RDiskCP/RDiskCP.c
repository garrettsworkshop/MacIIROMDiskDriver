#include <Devices.h>#include <A4Stuff.h>#define BootCheckbox 3#define BootCaption 6#define MountCheckbox 5#define MountCaption 8#define RAMCheckbox 7#define RAMCaption 10#define GWROMDiskSigAddr ((char*)0x40800004)#define GWROMDiskSigAdddr ((char*)0x40851D90)#pragma parameter __D0 RDiskCPReadXPRam(__D0, __D1, __A0)short RDiskCPReadXPRam(short size, short offset, char *where) = {0x4840, 0x3001, 0xA051};#pragma parameter __D0 RDiskCPWriteXPRam(__D0, __D1, __A0)short RDiskCPWriteXPRam(short size, short offset, char *where) = {0x4840, 0x3001, 0xA052};static long RDiskCPMacDev() {	int i;	const char sig[] = "\pRDisk";	// Check signature and return 0 if doesn't match	for (i = 0; i < sizeof(sig); i++) {		if (GWROMDiskSigAdddr[i] != sig[i]) {			// If signature doesn't match,			// fail if not holding R key			if (!((*((char*)0x175)) & 0x80)) { return 0; }		}	}	return 1; // Otherwise return 1 if signature matches}static void RDiskCPUpdate(DialogPtr cpDialog, short numItems, char startup, char ram) {	GrafPtr savePort;	Handle h;	Rect r;	short type;		// Save GrafPort and set port to dialog before updating items	GetPort(&savePort);	SetPort(cpDialog);		GetDItem(cpDialog, BootCheckbox+numItems, &type, &h, &r);	SetCtlValue((ControlHandle)h, startup & 0xFD ? 1 : 0);		GetDItem(cpDialog, MountCheckbox+numItems, &type, &h, &r);	SetCtlValue((ControlHandle)h, startup & 0x02 ? 1 : 0);	HiliteControl((ControlHandle)h, startup & 0xFD ? 255 : 0);		GetDItem(cpDialog, RAMCheckbox+numItems, &type, &h, &r);	SetCtlValue((ControlHandle)h, ram ? 1 : 0);	HiliteControl((ControlHandle)h, startup ? 0 : 255);		// Restore old GrafPort	SetPort(savePort);}static void RDiskCPHitDev(short message, short item, short numItems,				   short cpPrivateVal, EventRecord *theEvent,				   void *cdevStorageValue, DialogPtr cpDialog) {	char startup, ram;	RDiskCPReadXPRam(1, 4, &startup);	RDiskCPReadXPRam(1, 5, &ram);	switch (item - numItems) {		case BootCheckbox:			if (startup & 0xFD) { startup = startup & 0x02; }			else { startup = (startup & 0x02) | 0x01; }			break;		case MountCheckbox:			if (!(startup & 0xFD)) { startup = ~startup & 0x02; }			break;		case RAMCheckbox:			if (startup) { ram = !ram; }			break;	};	RDiskCPUpdate(cpDialog, numItems, startup, ram);	RDiskCPWriteXPRam(1, 4, &startup);	RDiskCPWriteXPRam(1, 5, &ram);}pascal long main(short message, short item, short numItems,				 short cpPrivateVal, EventRecord *theEvent,				 void *cdevStorageValue, DialogPtr cpDialog){	char startup, ram;	long ret = (long)cdevStorageValue;	// Switch to our A4 world	EnterCodeResource();	// Handle message	switch (message) {		case initDev:		case closeDev:			ret = cdevUnset; break;		case macDev:			ret = RDiskCPMacDev(); break;		case updateDev:		case activDev:		case deactivDev:			RDiskCPReadXPRam(1, 4, &startup);			RDiskCPReadXPRam(1, 5, &ram);			RDiskCPUpdate(cpDialog, numItems, startup, ram);			break;		case hitDev: 			RDiskCPHitDev(message, item, numItems,						  cpPrivateVal, theEvent,						  cdevStorageValue, cpDialog);			break;	};	// Restore old A4 world and return result	ExitCodeResource();	return ret;}